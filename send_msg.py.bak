#!/usr/bin/env python3
"""
LayerX Secure Messenger - SENDER
Automatic peer discovery + encrypted messaging with steganography
"""

import os
import json
import base64
import socket
import struct
import threading
import time
from nacl.public import PrivateKey, PublicKey, Box
from nacl.signing import SigningKey
import cv2

# Import LayerX steganography modules
from a3_image_processing import read_image, dwt_decompose, dwt_reconstruct
from a5_embedding_extraction import embed_in_dwt_bands

# Configuration
BROADCAST_PORT = 65432
CHAT_PORT = 9000
BROADCAST_INTERVAL = 5
MY_IDENTITY_FILE = 'my_identity.json'
PEERS_FILE = 'peers.json'

def get_local_ip():
    """Get local IP address"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip

def generate_keys(username):
    """Generate keys for new user"""
    signing_key = SigningKey.generate()
    encryption_key = PrivateKey.generate()
    
    return {
        "username": username,
        "ip": get_local_ip(),
        "signing_private": base64.b64encode(bytes(signing_key)).decode(),
        "signing_public": base64.b64encode(bytes(signing_key.verify_key)).decode(),
        "x25519_private": base64.b64encode(bytes(encryption_key)).decode(),
        "x25519_public": base64.b64encode(bytes(encryption_key.public_key)).decode()
    }

def load_or_create_identity():
    """Load or create identity"""
    if os.path.exists(MY_IDENTITY_FILE):
        with open(MY_IDENTITY_FILE) as f:
            identity = json.load(f)
        identity["ip"] = get_local_ip()
        with open(MY_IDENTITY_FILE, "w") as f:
            json.dump(identity, f, indent=2)
        print(f"âœ“ Loaded identity: {identity['username']} ({identity['ip']})")
        return identity
    
    username = input("Enter your username: ").strip()
    identity = generate_keys(username)
    with open(MY_IDENTITY_FILE, "w") as f:
        json.dump(identity, f, indent=2)
    print(f"âœ“ Created identity: {username}")
    return identity

def load_peers():
    """Load peers list"""
    if os.path.exists(PEERS_FILE):
        with open(PEERS_FILE) as f:
            return json.load(f)
    return []

def save_peers(peers):
    """Save peers list"""
    with open(PEERS_FILE, "w") as f:
        json.dump(peers, f, indent=2)

def broadcast_identity(my_identity, stop_event):
    """Broadcast presence to network"""
    ip_prefix = '.'.join(my_identity['ip'].split('.')[:3])
    broadcast_ip = f"{ip_prefix}.255"
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    
    payload = {
        "username": my_identity["username"],
        "ip": my_identity["ip"],
        "signing_public": my_identity["signing_public"],
        "x25519_public": my_identity["x25519_public"]
    }
    
    message = json.dumps(payload).encode()
    
    while not stop_event.is_set():
        try:
            sock.sendto(message, (broadcast_ip, BROADCAST_PORT))
        except:
            pass
        stop_event.wait(BROADCAST_INTERVAL)
    
    sock.close()

def listen_for_peers(my_identity, peers_list, stop_event):
    """Listen for peer broadcasts"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('', BROADCAST_PORT))
    sock.settimeout(1.0)
    
    while not stop_event.is_set():
        try:
            data, addr = sock.recvfrom(2048)
            peer = json.loads(data.decode())
            
            # Skip self
            if peer["username"] == my_identity["username"]:
                continue
            
            # Add or update peer
            existing = next((p for p in peers_list if p["username"] == peer["username"]), None)
            if not existing:
                peers_list.append(peer)
                save_peers(peers_list)
                print(f"\nğŸ†• Discovered: {peer['username']} ({peer['ip']})")
            elif existing["ip"] != peer["ip"]:
                existing.update(peer)
                save_peers(peers_list)
                
        except socket.timeout:
            continue
        except:
            pass
    
    sock.close()

def get_peer_by_ip(ip, peers_list):
    """Find peer by IP address"""
    return next((p for p in peers_list if p["ip"] == ip), None)

def encrypt_message(message, peer, my_identity):
    """Encrypt message with NaCl Box"""
    my_priv = PrivateKey(base64.b64decode(my_identity["x25519_private"]))
    peer_pub = PublicKey(base64.b64decode(peer["x25519_public"]))
    box = Box(my_priv, peer_pub)
    
    encrypted = box.encrypt(message.encode('utf-8'))
    
    # Sign the encrypted data
    signing_key = SigningKey(base64.b64decode(my_identity["signing_private"]))
    signed_data = signing_key.sign(encrypted)
    
    payload = {
        "sender": my_identity["username"],
        "signed_data": base64.b64encode(signed_data).decode()
    }
    
    return json.dumps(payload).encode('utf-8')

def embed_and_send(payload, peer_ip, cover_image="test_lena.png"):
    """Embed payload in image and send"""
    # Load and decompose image
    img = read_image(cover_image)
    bands = dwt_decompose(img)
    
    # Convert payload to bits
    payload_bits = ''.join(format(byte, '08b') for byte in payload)
    
    # Embed in DWT bands
    stego_bands = embed_in_dwt_bands(payload_bits, bands)
    
    # Reconstruct stego image
    stego_image = dwt_reconstruct(stego_bands)
    
    # Encode to PNG
    _, buffer = cv2.imencode('.png', stego_image)
    image_bytes = buffer.tobytes()
    
    # Send via TCP
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    sock.connect((peer_ip, CHAT_PORT))
    sock.sendall(struct.pack('>I', len(image_bytes)))
    sock.sendall(image_bytes)
    sock.close()

def main():
    """Main sender loop"""
    print("="*70)
    print("LAYERX SECURE MESSENGER - SENDER")
    print("="*70)
    
    my_identity = load_or_create_identity()
    peers_list = load_peers()
    stop_event = threading.Event()
    
    # Start broadcast thread
    threading.Thread(target=broadcast_identity, args=(my_identity, stop_event), daemon=True).start()
    
    # Start listener thread
    threading.Thread(target=listen_for_peers, args=(my_identity, peers_list, stop_event), daemon=True).start()
    
    print(f"\nğŸ“¡ Discovering peers... (wait ~5 seconds)\n")
    time.sleep(3)
    
    print("Commands:")
    print("  /list              - Show discovered peers")    print("  /add <user> <ip>   - Manually add peer")    print("  /send <ip>         - Send message to peer IP")
    print("  /image <path>      - Change cover image")
    print("  /quit              - Exit\n")
    
    cover_image = "test_lena.png"
    
    try:
        while True:
            cmd = input("Command: ").strip()
            
            if not cmd:
                continue
            
            if cmd == "/list":
                if peers_list:
                    print("\nğŸ“‹ Discovered Peers:")
                    for p in peers_list:
                        print(f"   â€¢ {p['username']} ({p['ip']})")
                else:
                    print("âš ï¸ No peers found yet\n")
            
            elif cmd.startswith("/send "):
                ip = cmd.split()[1] if len(cmd.split()) > 1 else None
                if not ip:
                    print("âŒ Usage: /send <ip>")
                    continue
                
                peer = get_peer_by_ip(ip, peers_list)
                if not peer:
                    print(f"âŒ Peer not found: {ip}")
                    continue
                
                message = input(f"Message to {peer['username']}: ").strip()
                if not message:
                    continue
                
                try:
                    print("ğŸ“¦ Encrypting... ", end='', flush=True)
                    payload = encrypt_message(message, peer, my_identity)
                    print("âœ“")
                    
                    print("ğŸ–¼ï¸ Embedding in image... ", end='', flush=True)
                    embed_and_send(payload, peer["ip"], cover_image)
                    print("âœ“")
                    
                    print(f"âœ… Sent to {peer['username']} ({ip})\n")
                except Exception as e:
                    print(f"âŒ Failed: {e}\n")
            
            elif cmd.startswith("/image "):
                path = cmd.split(maxsplit=1)[1]
                if os.path.exists(path):
                    cover_image = path
                    print(f"âœ“ Cover image: {path}\n")
                else:
                    print(f"âŒ File not found: {path}\n")
            
            elif cmd == "/quit":
                stop_event.set()
                print("ğŸ‘‹ Goodbye!")
                break
            
            else:
                print("âŒ Unknown command\n")
    
    except KeyboardInterrupt:
        stop_event.set()
        print("\nğŸ‘‹ Interrupted")

if __name__ == "__main__":
    main()
